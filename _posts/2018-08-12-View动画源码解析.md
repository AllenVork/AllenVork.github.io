---
layout:     post
title:      View 动画源码解析
subtitle:   
header-img: img/android3.png
author:     Allen Vork
catalog: true
tags:
    - android basics  
---

## Synopsis
前面在 Android 动画基础中已经简单讲了 View 动画的基本用法，本文将通过一个简单的例子来介绍 View 动画的内部原理。

## Sample
```kotlin
val alphaAnim = AlphaAnimation(0f, 1f)
alphaAnim.duration = 3000
button.startAnimation(alphaAnim)
```

## View.startAnimation()
首先我们来看下 View 的 startAnimation 到底做了什么：
```java
public void startAnimation(Animation animation) {
    animation.setStartTime(Animation.START_ON_FIRST_FRAME);
    setAnimation(animation);
    invalidateParentCaches();
    invalidate(true);
}
```
我们来看下 setAnimation(animation) 方法：
```java
public void setAnimation(Animation animation) {
    mCurrentAnimation = animation;
    if (animation != null) {
        // If the screen is off assume the animation start time is now instead of
        // the next frame we draw. Keeping the START_ON_FIRST_FRAME start time
        // would cause the animation to start when the screen turns back on
        if (mAttachInfo != null && mAttachInfo.mDisplayState == Display.STATE_OFF
                && animation.getStartTime() == Animation.START_ON_FIRST_FRAME) {
            animation.setStartTime(AnimationUtils.currentAnimationTimeMillis());
        }
        animation.reset();
    }
}
```
这里是将我们创建的 animation 对象赋值给 View 的 Animation 对象，并没有具体的动画逻辑，我们再来看下 invalidateParentCaches()：
```java
/**
 * Used to indicate that the parent of this view should clear its caches. This functionality
 * is used to force the parent to rebuild its display list (when hardware-accelerated),
 * which is necessary when various parent-managed properties of the view change, such as
 * alpha, translationX/Y, scrollX/Y, scaleX/Y, and rotation/X/Y. This method only
 * clears the parent caches and does not causes an invalidate event.
 *
 * @hide
 */
protected void invalidateParentCaches() {
     if (mParent instanceof View) {
         ((View) mParent).mPrivateFlags |= PFLAG_INVALIDATED;
      }
}
```
从注释可以看出，这个方法是给父 View 增加一个标志位，用于告诉它要清理自己的缓存。当多个由父 View 管理的该子 View 的属性（如 alpha, translationX/Y 等）变化时会用到。我们再往下看：
```java
    public void invalidate(boolean invalidateCache) {
        invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);
    }

    void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache,
            boolean fullInvalidate) {
            // ...
            // Propagate the damage rectangle to the parent view.
            final AttachInfo ai = mAttachInfo;
            final ViewParent p = mParent;
            if (p != null && ai != null && l < r && t < b) {
                final Rect damage = ai.mTmpInvalRect;
                damage.set(l, t, r, b);
                // 调用 parent 的 invalidateChild 来刷新
                p.invalidateChild(this, damage);
            }

            // ...
```
可以看出它调用了 ViewGroup 的 invalidateChild()方法：
```java
    public final void invalidateChild(View child, final Rect dirty) {
        // ...
        ViewParent parent = this;
        if (attachInfo != null) {
            // 如果子 View 要绘制动画，则要将该标志位复制给自己和自己的 parent 以确保刷新请求能通过
            final boolean drawAnimation = (child.mPrivateFlags & PFLAG_DRAW_ANIMATION) != 0;

            // ...
            do {
                View view = null;
                if (parent instanceof View) {
                    view = (View) parent;
                }

                if (drawAnimation) {
                    if (view != null) {
                        view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;
                    } else if (parent instanceof ViewRootImpl) {
                        ((ViewRootImpl) parent).mIsAnimating = true;
                    }
                }

                // ...

                // 循环调用该方法，直到 parent 为 null。循环开始时，parent 为自身。
                parent = parent.invalidateChildInParent(location, dirty);
                if (view != null) {
                    // Account for transform on current parent
                    Matrix m = view.getMatrix();
                    if (!m.isIdentity()) {
                        RectF boundingRect = attachInfo.mTmpTransformRect;
                        boundingRect.set(dirty);
                        m.mapRect(boundingRect);
                        dirty.set((int) Math.floor(boundingRect.left),
                                (int) Math.floor(boundingRect.top),
                                (int) Math.ceil(boundingRect.right),
                                (int) Math.ceil(boundingRect.bottom));
                    }
                }
            } while (parent != null);
        }
    }
```
可以看出它也是在设置一些参数，里面循环调用 invalidateChildInParent。我们进去看看：
```java
    /**
     * This implementation returns null if this ViewGroup does not have a parent,
     * if this ViewGroup is already fully invalidated or if the dirty rectangle
     * does not intersect with this ViewGroup's bounds.
     */
    public ViewParent invalidateChildInParent(final int[] location, final Rect dirty) {
        if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID)) != 0) {
            // either DRAWN, or DRAWING_CACHE_VALID
            if ((mGroupFlags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE))
                    != FLAG_OPTIMIZE_INVALIDATE) {
                dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX,
                        location[CHILD_TOP_INDEX] - mScrollY);
                if ((mGroupFlags & FLAG_CLIP_CHILDREN) == 0) {
                    dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
                }

                final int left = mLeft;
                final int top = mTop;

                if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                    if (!dirty.intersect(0, 0, mRight - left, mBottom - top)) {
                        dirty.setEmpty();
                    }
                }

                location[CHILD_LEFT_INDEX] = left;
                location[CHILD_TOP_INDEX] = top;
            } else {

                if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                    dirty.set(0, 0, mRight - mLeft, mBottom - mTop);
                } else {
                    // in case the dirty rect extends outside the bounds of this container
                    dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
                }
                location[CHILD_LEFT_INDEX] = mLeft;
                location[CHILD_TOP_INDEX] = mTop;

                mPrivateFlags &= ~PFLAG_DRAWN;
            }
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
            if (mLayerType != LAYER_TYPE_NONE) {
                mPrivateFlags |= PFLAG_INVALIDATED;
            }

            return mParent;
        }

        return null;
    }
```
从注解可以看出来，这个函数是返回当前 ViewGroup 的 parent 的。里面还没有看到具体的动画逻辑，由于 invalidateChildInParent 会一直循环执行，一直到 parent 为 null 为止，而 ViewGroup 的 parent 也是 ViewGroup，那么无论循环多少次都是调用一样的方法，都没有跟具体的动画逻辑有关系，那么动画到底是在哪里触发的呢？    
我们知道，我们的布局是通过 setContentView() 时添加到 DecorView 中的，那么 DecorView 就是 View 树的根布局，而 DecorView 其实是会在 WindowManagerGlobal 的 addView 方法被添加到 ViewRootImpl 中，这个才是真正的根布局（虽然并没有继承 ViewGroup)。我们来看下 ViewRootImpl 的 invalidateChildInParent 方法：
```java
    public ViewParent invalidateChildInParent(int[] location, Rect dirty) {
        // ...
        if (dirty == null) {
            invalidate();
            return null;
        } else if (dirty.isEmpty() && !mIsAnimating) {
            return null;
        }
        // ...
        invalidateRectOnScreen(dirty);

        return null;
    }
```
从 ViewGroup 的 invalidateChildInParent 方法里看出来 dirty 是不为空的，那么会直接走到 invalidateRectOnScreen 方法中：
```java
    private void invalidateRectOnScreen(Rect dirty) {
        // ...
        if (!mWillDrawSoon && (intersected || mIsAnimating)) {
            scheduleTraversals();
        }
    }

    void scheduleTraversals() {
        if (!mTraversalScheduled) {
            // ...
            mChoreographer.postCallback(
                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
            // ...
        }
    }

    final TraversalRunnable mTraversalRunnable = new TraversalRunnable();
    final class TraversalRunnable implements Runnable {
        @Override
        public void run() {
            doTraversal();
        }
    }

    void doTraversal() {
        if (mTraversalScheduled) {
            // ...
            performTraversals();
            // ...
        }
    }
``` 
可以看出它的目的是将 performTraversals() 方法封装到 Runnalbe 里，然后传给 Choreographer。我们来看下传给它后做了什么：
```java
    /**
     * Posts a callback to run on the next frame.
     * <p>
     * The callback runs once then is automatically removed.
     * </p>
     *
     * @param callbackType The callback type.
     * @param action The callback action to run during the next frame.
     * @param token The callback token, or null if none.
     *
     * @see #removeCallbacks
     * @hide
     */
    public void postCallback(int callbackType, Runnable action, Object token) {
        postCallbackDelayed(callbackType, action, token, 0);
    }
```
从注释可以看出，这个将 Runnable 传进来是为了在屏幕绘制下一帧的时候去执行。也就是我们调用 start 启动动画后并不是直接执行的，而是在屏幕绘制下一帧的时候才会执行。这个方法最终会调用到：
```java
    private void postCallbackDelayedInternal(int callbackType,
            Object action, Object token, long delayMillis) {
        synchronized (mLock) {
            final long now = SystemClock.uptimeMillis();
            final long dueTime = now + delayMillis;
            
            // 会将 Runnable 封装到 CallbackRecord 中，然后存入队列中
            mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);

            if (dueTime <= now) {
                scheduleFrameLocked(now);
            } else {
                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);
                msg.arg1 = callbackType;
                msg.setAsynchronous(true);
                mHandler.sendMessageAtTime(msg, dueTime);
            }
        }
    }
```
Runnable 被存入到 Choreographer 的待执行队列中，当屏幕绘制信号（安卓手机屏幕刷新频率为60fps，也就是16.7ms屏幕会刷新一次）到来时会被执行，这样 ViewRootImpl 的 performTranversals() 就会执行。这个方法是从 DecorView 开始遍历 View 树来执行 onMeasure 等操作的。由于每一次页面刷新都会执行 ViewRootImpl 的 performTraversal() 操作来遍历 View 树，找到发生改变的 View 来执行 onMeasure 等操作，所以我们写布局时要尽量减少层级。

**我们来总结下调用 startAnimation 后的流程：**
![]({{site.url}}/img/android/anim/startAnimation1.png)   
1. 调用 View.StartAnimation(Animation) 方法后，会调用 setAnimation() 将这个 animation 会作为 View 的全局变量保存起来
2. 然后调用 View 的 invalidate() 方法，它会调用 parent.invalidateChild() 方法来调到 ViewGroup 中的该方法。
3. 这时 ViewGroup 会循环执行`parent = parent.invalidateChildInParent(location, dirty)` 直到 parent 为空。

整个过程就处理完了，但 ViewGroup 中的 invalidateChildInParent 都是在处理一些参数，并没有和动画有直接联系，那动画到底是在哪里处理的？想到整个 View 树的 parent 不仅仅是 ViewGroup，它的顶层是 ViewRootImpl。ViewRootImpl 中的 invalidateChildInParent() 才是核心所在。它会将一个会执行 performTraversals() 的 Runnable 传到 Choreographer,当屏幕绘制下一帧的时候就会执行。真正跟动画相关的代码在 performTraversals() 中。

## 参考文献
+ [android 动画系列 (2) - interpolator 插值器](https://www.jianshu.com/p/48317612c164)   
+ [模拟自然动画的精髓——TimeInterpolator与TypeEvaluator](https://www.jianshu.com/p/b239d14060a8) 